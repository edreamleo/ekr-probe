<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20240217100609.1"><vh>Startup</vh>
<v t="ekr.20240217100529.2"><vh>@button backup</vh></v>
<v t="ekr.20240217100529.3"><vh>@button screen-save</vh></v>
<v t="ekr.20240217100609.9"><vh>@settings</vh>
<v t="ekr.20240217100609.50"><vh>@data history-list</vh></v>
</v>
<v t="ekr.20240217100609.220"><vh>script: Recursive import</vh>
<v t="ekr.20240217100609.221"><vh>&lt;&lt; rust dir_list &gt;&gt;</vh></v>
</v>
<v t="ekr.20240217100609.258"><vh>script: remove copyright</vh></v>
</v>
<v t="ekr.20240217100455.1"><vh>The probe project</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20240217100455.1">@language rest
@wrap

- coverage.py is super fast.  Why?

- @probe decorator should be faster than Sherlock/coverage.

- node-level caching, like node-level git diff.

- ? Create an ekr-probe repo ??</t>
<t tx="ekr.20240217100529.2">"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='ekr-private')
</t>
<t tx="ekr.20240217100529.3">"""Run screen-save.cmd"""
g.execute_shell_commands("ss")
</t>
<t tx="ekr.20240217100609.1"></t>
<t tx="ekr.20240217100609.220">@language python
"""Recursively import all python files in a directory and clean the result."""
@tabwidth -4 # For a better match.
g.cls()
&lt;&lt; rust dir_list &gt;&gt;

dir_ = r'C:\Python\Python3.12\Lib\site-packages\coverage'

c.recursiveImport(
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    recursive = True,
    safe_at_file = True,
    # '.html', '.js', '.json', '.py', '.rs', '.svg', '.ts', '.tsx']
    # '.codon', '.cpp', '.cc', '.el', '.scm',
    theTypes = ['.py'],
    verbose = False,
)
if 1:
    last = c.lastTopLevel()
    last.expand()
    if last.hasChildren():
        last.firstChild().expand()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20240217100609.221">dir_list = (
    r'C:\Repos\RustPython\common\src',
    r'C:\Repos\RustPython\compiler\codegen\src',
    r'C:\Repos\RustPython\compiler\core\src',
    r'C:\Repos\RustPython\compiler\src',
    r'C:\Repos\RustPython\compiler\codegen\src',  # compile.rs: AST to bytecode.
    r'C:\Repos\RustPython\compiler\core\src', # bytecode.rs: implements bytecodes.
    
    r'C:\Repos\RustPython\derive\src',
    r'C:\Repos\RustPython\derive-impl\src',
    r'C:\Repos\RustPython\pylib\src',
    r'C:\Repos\RustPython\src',
    r'C:\Repos\RustPython\stdlib\src',
    r'C:\Repos\RustPython\vm\src', # compiler.rs.
    r'C:\Repos\RustPython\vm\src\stdlib', # *****ast.rs  Also, many .rs versions of stdlib.
    r'C:\Repos\RustPython\vm\src\vm',  # compile.rs.
    r'C:\Repos\RustPython\vm\src\stdlib\ast', # gen.rs automatically generated by ast/asdl_rs.py.
)
</t>
<t tx="ekr.20240217100609.258">h = '--- @edit files'
root = g.findTopLevelNode(c, h)
start_s = 'LilyPond is free software:'
end_s = 'If not, see &lt;http://www.gnu.org/licenses/&gt;.'
for p in root.children():
    s = p.b
    i = s.find(start_s)
    j = s.find(end_s)
    if -1 &lt; i &lt; j:
        s = s[:i] + s[j + len(end_s):]
        p.b = s
    else:
        print('not found', p.h)
print('done')</t>
<t tx="ekr.20240217100609.50">execute-script
backup

# import-to-indented-lisp
# import-to-indented-typescript
# import-to-indented-c

# refresh-from-disk
# pylint
# show-plugin-handlers
# merge-node-with-next-node
# merge-node-with-prev-node
# beautify-files
</t>
<t tx="ekr.20240217100609.9" __bookmarks="7d7100580700000069735f6475706571014930300a732e">@language rest
@wrap

The @settings tree contains all active settings. 

Settings outside this tree have no effect.</t>
</tnodes>
</leo_file>
